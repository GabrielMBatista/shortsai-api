generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                      String           @id @default(uuid())
  email                   String           @unique
  name                    String?
  avatar_url              String?
  google_id               String?          @unique
  subscription_plan       SubscriptionPlan @default(FREE)
  stripe_customer_id      String?
  created_at              DateTime         @default(now())
  tier                    Tier             @default(free)
  updated_at              DateTime         @default(now()) @updatedAt
  emailVerified           DateTime?        @map("email_verified")
  image                   String?
  is_blocked              Boolean          @default(false)
  role                    Role             @default(USER)
  last_video_generated_at DateTime?
  plan_id                 String?
  accounts                Account[]
  api_keys                ApiKey?
  characters              Character[]
  folders                 Folder[]
  projects                Project[]
  sessions                Session[]
  shows                   Show[]
  social_posts            SocialPost[]
  usage_logs              UsageLog[]
  user_limits             UserLimits?
  videoTransferJobs       VideoTransferJob[]
  plan                    Plan?            @relation(fields: [plan_id], references: [id])

  @@map("users")
}

model Plan {
  id                   String   @id @default(uuid())
  name                 String   @unique
  slug                 String   @unique
  description          String?
  price                Decimal  @default(0)
  monthly_images_limit Int      @default(10)
  monthly_videos_limit Int      @default(5)
  monthly_minutes_tts  Int      @default(10)
  daily_requests_limit Int      @default(50)
  daily_videos_limit   Int      @default(2)
  features             Json?
  created_at           DateTime @default(now())
  updated_at           DateTime @updatedAt
  users                User[]

  @@map("plans")
}

model Account {
  id                String   @id @default(uuid())
  userId            String   @map("user_id")
  type              String
  provider          String
  providerAccountId String   @map("provider_account_id")
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  
  // Google Drive Sync State
  drivePageToken         String?
  driveChannelId         String?
  driveChannelResourceId String?
  driveChannelExpiration DateTime?

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model ApiKey {
  user_id        String   @id
  gemini_key     String?
  elevenlabs_key String?
  suno_key       String?
  updated_at     DateTime @default(now()) @updatedAt
  groq_key       String?
  user           User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("api_keys")
}

model Show {
  id                   String      @id @default(uuid())
  user_id              String
  name                 String
  description          String?
  style_preset         String?
  visual_prompt        String?
  default_tts_provider TTSProvider @default(gemini)
  created_at           DateTime    @default(now())
  updated_at           DateTime    @updatedAt
  characters           Character[]
  episodes             Project[]
  user                 User        @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@map("shows")
}

model Project {
  id                            String              @id @default(uuid())
  user_id                       String
  topic                         String
  style                         String
  language                      String              @default("en")
  voice_name                    String
  tts_provider                  TTSProvider
  reference_image_url           String?
  include_music                 Boolean             @default(false)
  bg_music_prompt               String?
  bg_music_url                  String?
  bg_music_status               MusicStatus?
  created_at                    DateTime            @default(now())
  updated_at                    DateTime            @default(now()) @updatedAt
  generated_description         String?
  generated_title               String?
  reference_characters_snapshot Json?
  status                        ProjectStatus       @default(draft)
  duration_config               Json?
  lock_expires_at               DateTime?
  lock_session_id               String?
  video_model                   String              @default("veo")
  folder_id                     String?
  is_archived                   Boolean             @default(false)
  tags                          String[]            @default([])
  audio_model                   String?
  episode_number                Int?
  show_id                       String?
  final_video_url               String?
  ProjectCharacters             ProjectCharacters[]
  folder                        Folder?             @relation(fields: [folder_id], references: [id], onDelete: Cascade)
  show                          Show?               @relation(fields: [show_id], references: [id])
  user                          User                @relation(fields: [user_id], references: [id], onDelete: Cascade)
  scenes                        Scene[]
  social_posts                  SocialPost[]
  usage_logs                    UsageLog[]

  @@index([user_id])
  @@index([show_id])
  @@map("projects")
}

model Folder {
  id         String    @id @default(uuid())
  name       String
  user_id    String
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  parent_id  String?
  parent     Folder?   @relation("SubFolders", fields: [parent_id], references: [id], onDelete: Cascade)
  children   Folder[]  @relation("SubFolders")
  user       User      @relation(fields: [user_id], references: [id], onDelete: Cascade)
  projects   Project[]

  @@unique([user_id, name])
  @@index([user_id])
  @@map("folders")
}

model Scene {
  id                 String      @id @default(uuid())
  project_id         String
  scene_number       Int
  visual_description String
  narration          String
  duration_seconds   Decimal     @db.Decimal(5, 2)
  image_url          String?
  image_status       SceneStatus @default(draft)
  audio_url          String?
  audio_status       SceneStatus @default(draft)
  created_at         DateTime    @default(now())
  error_message      String?
  sfx_status         SceneStatus @default(draft)
  sfx_url            String?
  audio_attempts     Int         @default(0)
  image_attempts     Int         @default(0)
  sfx_attempts       Int         @default(0)
  deleted_at         DateTime?
  word_timings       Json?
  video_status       SceneStatus @default(draft)
  video_url          String?
  video_attempts     Int         @default(0)
  media_type         String      @default("image")
  status             String      @default("DRAFT")
  version            Int         @default(0)
  visual_effect      String      @default("zoom_in")
  jobs               Job[]
  project            Project     @relation(fields: [project_id], references: [id], onDelete: Cascade)
  characters         Character[] @relation("SceneToCharacter")

  @@index([project_id])
  @@index([project_id, scene_number])
  @@map("scenes")
}

model Job {
  id           String   @id @default(cuid())
  type         String
  status       String   @default("QUEUED")
  inputPayload Json
  outputResult Json?
  errorMessage String?
  projectId    String
  sceneId      String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  scene        Scene?   @relation(fields: [sceneId], references: [id])

  @@index([status])
  @@index([sceneId])
}

model UserLimits {
  user_id                  String   @id
  monthly_videos_limit     Int      @default(5)
  monthly_minutes_tts      Int      @default(10)
  monthly_images_limit     Int      @default(50)
  current_videos_used      Int      @default(0)
  current_minutes_tts_used Decimal  @default(0) @db.Decimal(10, 2)
  current_images_used      Int      @default(0)
  last_reset_date          DateTime @default(now())
  current_daily_requests   Int      @default(0)
  daily_requests_limit     Int      @default(100)
  last_daily_reset         DateTime @default(now())
  current_daily_videos     Int      @default(0)
  daily_videos_limit       Int      @default(1)
  user                     User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_limits")
}

model Character {
  id                String              @id @default(uuid())
  user_id           String
  name              String
  description       String?
  created_at        DateTime            @default(now())
  images            String[]
  show_id           String?
  voice_id          String?
  voice_provider    TTSProvider?
  voice_settings    Json?
  ProjectCharacters ProjectCharacters[]
  show              Show?               @relation(fields: [show_id], references: [id])
  user              User                @relation(fields: [user_id], references: [id], onDelete: Cascade)
  scenes            Scene[]             @relation("SceneToCharacter")

  @@index([user_id])
  @@map("characters")
}

model UsageLog {
  id               String         @id @default(uuid())
  user_id          String?
  project_id       String?
  action_type      UsageLogAction
  provider         String
  model_name       String
  tokens_input     Int            @default(0)
  tokens_output    Int            @default(0)
  duration_seconds Decimal        @default(0) @db.Decimal(10, 2)
  status           UsageLogStatus
  error_message    String?
  created_at       DateTime       @default(now())
  idempotency_key  String?        @unique
  project          Project?       @relation(fields: [project_id], references: [id])
  user             User?          @relation(fields: [user_id], references: [id])

  @@index([user_id])
  @@index([project_id])
  @@map("usage_logs")
}

model SocialPost {
  id            String         @id @default(uuid())
  userId        String         @map("user_id")
  projectId     String         @map("project_id")
  platform      SocialPlatform
  accountId     String?        @map("account_id")
  title         String?
  description   String?
  tags          String[]
  privacyStatus PrivacyStatus  @default(PRIVATE)
  scheduledAt   DateTime?      @map("scheduled_at")
  publishedAt   DateTime?      @map("published_at")
  status        PostStatus     @default(DRAFT)
  error         String?
  externalId    String?
  createdAt     DateTime       @default(now()) @map("created_at")
  updatedAt     DateTime       @updatedAt @map("updated_at")
  project       Project        @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("social_posts")
}

model ProjectCharacters {
  A          String
  B          String
  characters Character @relation(fields: [A], references: [id], onDelete: Cascade)
  projects   Project   @relation(fields: [B], references: [id], onDelete: Cascade)

  @@id([A, B], map: "_ProjectCharacters_AB_pkey")
  @@index([B], map: "_ProjectCharacters_B_index")
  @@map("_ProjectCharacters")
}

enum SubscriptionPlan {
  FREE
  PRO
}

enum Tier {
  free
  pro
  enterprise
}

enum TTSProvider {
  gemini
  elevenlabs
  groq
}

enum MusicStatus {
  draft
  pending
  queued
  loading
  completed
  failed
  error
}

enum SceneStatus {
  draft
  pending
  queued
  processing
  loading
  completed
  failed
  error
}

enum ProjectStatus {
  draft
  generating
  completed
  failed
  paused
}

enum UsageLogAction {
  GENERATE_SCRIPT
  GENERATE_IMAGE
  GENERATE_TTS
  GENERATE_MUSIC
  GENERATE_VIDEO
}

enum UsageLogStatus {
  success
  failed
}

enum Role {
  USER
  ADMIN
}

enum SocialPlatform {
  YOUTUBE
  TIKTOK
  INSTAGRAM
}

enum PrivacyStatus {
  PRIVATE
  UNLISTED
  PUBLIC
}

enum PostStatus {
  DRAFT
  SCHEDULED
  PUBLISHING
  PUBLISHED
  FAILED
}

model VideoTransferJob {
  id              String    @id @default(uuid())
  userId          String
  
  // Metadados do Drive (Origem)
  driveFileId     String
  driveFileName   String
  driveMimeType   String
  driveFileSize   BigInt
  driveChecksum   String?

  // Metadados do YouTube (Destino)
  youtubeVideoId  String?
  youtubeStatus   String?
  publishAt       DateTime?

  // Controle de Execução
  status          VideoTransferStatus @default(QUEUED)
  progress        Int       @default(0)
  attempts        Int       @default(0)
  lastError       String?   @db.Text
  
  // Timestamps
  createdAt       DateTime  @default(now())
  startedAt       DateTime?
  completedAt     DateTime?

  user            User      @relation(fields: [userId], references: [id])
  
  @@index([userId, status])
  @@index([driveFileId])
}

enum VideoTransferStatus {
  QUEUED
  PROCESSING
  WAITING_QUOTA
  COMPLETED
  FAILED
}
